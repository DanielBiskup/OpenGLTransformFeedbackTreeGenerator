\chapter{Implementierung}
Dieses Kapitel behandelt das diesem Dokument beiliegende Programm.
Zunächst wird Überblick darüber gegeben, wie das Programm zu bedienen ist. Anschließend wird auf die verwendeten Libraries, und den Aufbau des Programmes eingegangen. Zuletzt wird ausgeführt wie das Programm auf den Plattformen Windows und Linux kompiliert werden kann.

\section{Bedienung des Programmes}
\begin{figure} %[hbtp]
	\centering
	\includegraphics{images/applicationScreenShot.png}
	\caption{Geometrie}
	\label{IABB1}
\end{figure}

Nach dem Start des Programmes ist in der Mitte des Fensters ein sich drehender Baum zu sehen. In der linken oberen Ecke befindet sich ein Fenster mit der mit dem Titel "'TweakBar"' welches im Folgenden als Tweak Bar bezeichnet wird (siehe Abbilding \ref{IABB1}).

Die Tweak Bar enthält drei Gruppen von Einträgen, mit Namen "'generation parameters"', "'presentation parameters"' und "'read-only scene information"'.

Während die ersten Beiden Gruppen Felder die vom Benutzer oder der Benutzerin manipuliert werden können enthalten, enthält die letzte Gruppe die nicht vom Benutzer oder der Benutzerin nicht direkt manipulierbaren Einträge "'number of triangles"' und "'number of vertices"'. Unter "'number of triangles"' ist die Anzahl der Dreiecke und unter "'number of vertices"' anderen die Anzahl der Eckpunkte aufgeführt, aus denen sich der aktuell auf dem Bildschirm angezeigt Baum zusammensetzt.

In der Gruppe "'presentation parameters"' findet der Benutzer oder die Benutzerin den Schalter "'autoRotation"' mit dem sich festlegen lässt, ob der Baum automatisch entlang seiner Y-Achse gedreht werden soll, sowie das Eingabefeld "'autoRotationSpeed"' über welches die bei automatischer Rotation anzuwendende Rotationsgeschwindigkeit festgelegt werden kann.
Über den Eintrag "'rotation"' kann durch klicken und ziehen der bunt eingefärbten Kugel die Orientierung des Baumes im Raum verändert werde.

In der Gruppe "'generation parameters"' sind Einträge aufgeführt über die sich der Prozess der Geometriegenerierung des Baumes konfigurieren lässt.
Den ersten Eintrag bildet ein Button mit Aufschrift "'click here to generate tree"'. Ein Klick auf diesen löst die Ausführung des in Kapitel \ref{capter_geometrie} beschriebenen Geometrieerzeugungsalgorithmus aus, welchem als Parameter die Werte der übrigen Eingabefelder, die in der Gruppe "'generation parameters"' enthalten sind, übergeben werde. Wurde die Geometrie erfolgreich erzeugt, so wird der diese nun anstelle der zuvor angezeigten angezeigt.

Der Parameter "'numberOfIterations"' gibt an, wie viele Iterationen des Geometrieerzeugungsalgorithmus verwendet werden sollen.

Die übrigen Parameter sind bereits aus \ref{capter_geometrie} bekannt, ihr Bedeutung soll hier dennoch kurz geklärt werden.

Der Parameter "'scaleLength"' bestimmt, wie lang ein Astsegment im Verhältnis zu seinem Vorgänger ist.

Der Parameter "'scaleTriangle"' bestimmt, wie dick das obere Ende eines Astsegmentes im Verhältnis zu seinem Unteren Ende ist.

Der Parameter "'pyramidFactor"' bestimmt, wie hoch die Pyramide am Ende eines Astsegmentes im Verhältnis zu dessen Länge ist.

Die Parameter können auch über Tasten auf der Tastatur verändert werden. Welche Tasten verwendet werden können um einen Parameter zu verändern wird angezeigt, wenn der Cursor über dem Eingabefeld für den Parameter steht.

In der unteren linken Ecke des Fensters ist ein kleines Dreieck zu sehen. Ein Klick darauf öffnet ein Fenster, in welchem die Parameter, ähnlich wie in dem Dokument was sie gerade lesen, kurz erklärt werden.

\section{Verwendet Libraries}
Das Programm nutzt mehrere plattformunabhänge Open Source Libraries.
\paragraph{GLEW}
\url{http://glew.sourceforge.net/}
Sorgt dafür, dass man als Programmierer gleich die OpenGL Funktionen aufrufen kann, ohne sich selbst darum kümmern zu müssen irgendwie an die functionpointer zu diesen Funktionen zu kommen.

\paragraph{GLFW}
\url{http://www.glfw.org/}
Vergleichbar mit SDL oder FreeGLUT. Erstellt Fenster und den OpenGL Kontext. Bietet Methoden zur Eingabebehandlung von Mouse und Tastatur.

\paragraph{GLM}
\url{http://glm.g-truc.net/0.9.6/index.html}
Eine Header-Only Library die sich um Mathematik kümmert. Sie stellt unter anderem eine Klasse für Quaternionen zur verfügung und Methoden um View- und Projection-Matrizen zu erzeugen.

\paragraph{AntTweakBar}
\url{http://anttweakbar.sourceforge.net/doc/}
Erlaubt es schnell und einfach einfache Bedienelemente in die eigene OpenGL Anwendung zu integrieren. Sie bietet wie auf dem Folgenden Link zu sehen ist Methoden um sie ganz leicht mit GLFW2, SDL, usw. zu verbinden. \url{http://anttweakbar.sourceforge.net/doc/tools:anttweakbar:howto#5._handle_mouse_and_keyboard_events_and_window_size_changes}
GLFW3, welches ich hier nutze, bringt allerdings API-Änderungen und AntTweakBar unterstützt GLFW3 nicht. \url{http://sourceforge.net/p/anttweakbar/tickets/11/}. Deshalb habe ich in \code{tweakbarutil.cpp} ein paar Methoden geschrieben, welche dieses Problem für mich teilweise lösen.

\section{Aufbau des Programmes}

\subsection{Wrapperklassen für OpenGL Objekte}
Ich habe versucht Wrapperklassen für OpenGL Objekte zu schreiben. Dabei habe ich mich von folgendem Projekt inspirieren lassen. Ich möchte betonen, dass ich dennoch nicht einfach den Quelltext des Projektes geklaut habe, sondern, dass ich mir selbst Gedanken gemacht habe. \url{https://github.com/Overv/OOGL}.

\subsection{Transform Feedback und Geometry Shader}
Quellen die ich genutzt habe um Transform Feedback und Geometry Shader zu verstehen sind: \url{https://open.gl/geometry} und \url{https://open.gl/feedback}. Erste Erfahrung mit OpenGL habe ich schon vor einem halben Jahr gemacht, damals halfen mir folgende Websites sehr weiter: \url{http://www.opengl-tutorial.org/} und \url{http://arcsynthesis.org/?nr=0} (die seit ein paar Wochen nicht mehr online ist).

Ich habe auch öfter direkt in der OpenGL Dokumentation nachgeschaut, bzw. auf der folgenden etwas übersichtlicher strukturierten Website \url{http://docs.gl/}.

Bei der Implementierung der Geometriegenerierung habe ich mich an ihren Vorschlag aus der Aufgabenstellung gehalten. Ich verwende zwei VBOs und zwei VAOs. Zwei VBOs, weil ich immer einen VBO als Input für die Pipeline und den anderen als Ziel für die Ausgabe per Transform Feedback verwende. Zwei VAOs, weil ich abwechselnd den einen oder den anderen VBO als Eingabe verwende, und VAOs speichern aus welchem VBO die Daten für die einzelnen Attribute kommen. In meinem Programm halte ich eine Instanz vom Typ \code{Vertex""Arrays""And""Buffers} die jeweils Pointer auf die aktuellen Eingabe- und Ausgabebuffer und die zu ihnen gehörenden VAOs enthält. Die Funktion \code{void"" generate(""Vertex""Arrays""And""Buffers""\& vertex""Arrays""AndBufers"", Shaderprogram""\& shader"", int"" number""Of""Iterations"")} zum Beispiel erwartet eine Referenz auf diese Struktur um zu wissen welcher VBO und VAO gerade zur Eingabe und welcher zu Ausgabe verwendet werden soll. \code{generate} Vertauscht zudem bei Bedarf auch die Pointer in der Struct miteinander, damit auch andere Teile des Programms, wie zum Beispiel der Renderer im Main-Loop, wissen welches VAO sie zum Rendern verwenden müssen.

\subsection{OpenGL Errorbehandlung}
Wenn man sich als Programmierer oder Programmiererin nicht darum kümmert wird einem ein OpenGL Programm nicht mitteilen, warum es gerade abgestürzt ist. OpenGL bietet allerdings einige Funktionen, mit denen man sich relativ hilfreiche Fehlermeldungen ausgeben lassen kann. So sollte man sich nach dem Kompilieren von Shadern und dem Linken von Shaderprogrammen jeweils den Error-Log ausgeben lassen mit \code{glGetProgramiv}, \code{glGetProgramInfoLog}, \code{glGetShaderiv} und \code{glGetShaderInfoLog}. Ich verwende diese in meinem Programm in den Funktionen \code{void Shaderprogram::linkProgram} und \code{void ""Shader""::""create""Shader""From""String}.

Allgemein ist es eine gute Idee, \code{glDebugMessageCallback} zu verwenden, welches einem Erlaubt eine Callbackfunktion anzumelden, die immer aufgerufen wird, wenn ein Fehler auftritt. Ich habe mich an der folgenden Website bedient und den Code für die Funktion großteils übernommen, man könne auch sagen, ich habe sie geklaut: \url{http://blog.nobel-joergensen.com/2013/02/17/debugging-opengl-part-2-using-gldebugmessagecallback/}.
In meinem Programm Befindet sich die Implementierung dieser Funktion in \code{opengl""error""callback.""cpp}.

\section{Der Build Prozess}
Sowohl unter Windows als auch unter Linux wird das Tool \code{Premake} verwendet um Makefiles oder VS-StudioSolutions zu generieren. \url{https://premake.github.io/}. Premake erfüllt den selben Zweck wie CMake, und verwendet Lua als Scripsprache.
Ich musste mich auch ein wenig in die Nutzung dieses Werkzeugs einarbeiten, dabei half der User Guide des Projektes: \url{http://industriousone.com/scripting-premake}

\subsection{Der Build Prozess unter Windows 7 mit VisualStudio 2012}
Der Beschriebene Buildprozess wurde auf den Poolrechnern in Raum L3 getestet.
Entpacken sie \code{Projekt\_Windows.rar}. Navigieren sie zu \code{Projekt\_Windows/""Projekt/""Projekt/""project}. Dort finden sie die Ausführbare Datei \code{premake4.exe}, dies ist das Build Tool. Halten sie \code{CTRL + SHIFT} gedrückt, während sie mit der rechten Mousetaste irgendwo in das gerade geöffnete Fenster des Filemanagers klicken. Es öffnet sich ein Kontextmenü. Wählen sie \code{Eingabeaufforderung hier öffnen} aus. In der nun offenen CMD geben sie den Befehl \code{premake4.exe vs2012} ein, welcher ein *.sln-File für Visual Studio 2012 generiert. Doppelklicken sie auf \code{ProcedualTreeGeneration.sln}. Sollte VS 2012 nun gestartet sein, im Projektmappen-Explorer jedoch nur ein \code{MyFirstTree (Laden fehlgeschlagen)} stehen, rechts-klicken sie darauf, und wählen \code{Projekt erneut laden} aus. Nun können sie durch einen Klick auf \code{Lokaler Windows-Debugger} das Programm kompilieren und linken. Normalerweise sollte das es ohne Fehler (mit ein paar Warnungen) kompilieren und linken. Es wird anschließen versuchen zu starten und kurz danach abstürzen.

Es wird in Zeile 94 der Datei \code{buffer.cpp} beim Ausführen des Befehls \code{gl""Buffer""Sub""Data""(...)} abstürzen. Ich konnte den Fehler leider nicht beheben.

\subsection{Der Build Prozess unter Linux}
Auf meinem System, einem Arch Linux, kompiliert, linkt und läuft das Programm fehlerfrei. Um das es unter Linux zu kompilieren müssen sie zunächst folgende Abhängigkeiten auflösen indem sie die entsprechenden Pakete ihrer Distribution installieren oder von Hand die benötigten Bibliotheken installieren.

Wie sie \code{AntTweakBar} installieren ist hier beschrieben: \url{http://anttweakbar.sourceforge.net/doc/tools:anttweakbar:download}. Alternativ gibt es für einige Distributionen Packete. ArchLinux: \url{https://aur.archlinux.org/packages/anttweakbar/}, Fedora: \url{https://apps.fedoraproject.org/packages/AntTweakBar}, Gentoo: \code{http://gpo.zugaina.org/media-libs/anttweakbar}.

Sind alle Abhängigkeiten aufgelöst, so kompilieren sie folgendermaßen. Entpacken sie code{Projekt\_Linux.rar}. Navigieren sie mit der Bash nach \code{Projkt\_Linux/""Projekt/""project}. In diesem Ordner liegt bereits die Ausführbare Datei des Buildtools Premake. Generieren sie die GNU-Makefiles mit dem Befehl \code{./premake4 gmake}. Anschließend sollte im Ordner die Datei \code{Makefile} enthalten sein. Die Debug-Version kompilieren sie nun mit \code{make config=debug} und die Release-Version mit \code{make config=release}. Die Ausführbaren Programme liegen nun, falls der Kompilier- und Linkvorgang erfolgreich waren, in \code{./bin/debug} bzw. \code{./bin/release}. Ausführen können sie diese meist mit Doppelklick oder über die Bash.